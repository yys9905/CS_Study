# CS_Study
2023-10-20 시작
#Contents
1. [네트워크](#네트워크)
   1) [TCP / UDP](#tcp와-udp의-차이점에-대해서-설명해보세요-231020)
   2) [RESTful](#restful이란-무엇이며,-이것에-대해서-아는대로-설명해보세요.-231030)
2. [운영체제](#운영체제)
   1) [Process/thread](프로세스와-스레드의-차이를-설명해보세요.-231101)
3. [암호학/보안](#암호학/보안)
4. [프로그래밍 패러다임](#프로그래밍-패러다임)
    1) [객체지향 / 절차지향](#객체지향과-절차지향에-대해-설명해주세요-231025)
    2) [동기 / 비동기](#동기와-비동기-코드-실행방식에-대해-설명해주세요-231027)
# 네트워크
## - TCP와 UDP의 차이점에 대해서 설명해보세요. (231020)
- 네트워크 통신이 일어나는 과정을 나눈 표준모델인 OSI 7계층 중 4계층 및 TCP/IP 4계층 중 3계층인 전송계층에 있는 전송방식으로 송신자와 수신자를 연결하는 통신 서비스를 제공하는서 사용되는 방법 두가지
### - TCP(Transmission Control Protocol)
- 연결 지향 방식, 패킷 교환방식
- 3way handshaking 으로 연결 4way handshaking으로 해제
- 흐름제어 - 송.수신측의 데이터 처리속도 차이 줄이기 위함, receiver가 현재 상태를 sender에게 피드백해 패킷 수를 조절
- 위 두가지 기능 가능
- 높은 신뢰성- 낮은 성능
- 전이중(각각의 독립된 회선 사용), 점대점(1대1통신) 방식
- 각각의 패킷들은 연결되어있으며 번호가 매겨짐
- 신뢰성있는 전송이 필요할때 사용
- 가변길이 헤더
- 예시 (S:SYN, .:ACK, P:PSH, F:FIN)
![tcpex](https://raw.githubusercontent.com/yys9905/CS_Study/main/yang/image/tcpex.png)
### - UDP(***User Datagram Protocol)***
- 비연결형 방식, 데이터그램 방식
- 정보를 주고받을떄 신호절차를 가지고 있지 않음
- UDP헤더의 CheckSum 필드로 최소한의 오류 검출
- 낮은 신뢰성 -높은 성
- 각각의 패킷들은 독립되어있다
- 빠른 전송이 필요할때 사용
- 고정 길이 헤더
- 예시
![udpex](https://raw.githubusercontent.com/yys9905/CS_Study/main/yang/image/udpex.png)
- 일반적으로는 저런 내용이지만 UDP는 커스터마이징이 가능하며 개발자의 역량에 따라서 UDP를 이용해 TCP와 비슷한 신뢰성 가지게 할 수 있음
ex) QUIC

## RESTful이란 무엇이며, 이것에 대해서 아는대로 설명해보세요. (231030)
### REST(Representational State Transfer)
작동 방식에 대한 조건을 부과하는 소프트웨어 아키텍처이며 Client와 Server사이의 통신 방식 중 하나이다.
자원을 이름으로 구분하여 해당 자원의 상태를 주고 받는 모든것을 의미한다. 
(*자원 - 소프트웨어가 관리하는 모든것 *상태 - 요청되어지는 시점에서의 자원의 상태 JSON, XML로 주고받는게 일반적)

- HTTP URI를 통해 자원을 명시하고, HTTP Method(Post, GET, PUT, DELETE)를 통해 자원에 대한 CRUD를 적용하는 것
- 자원 기반구조(ROA, Resource Oriented Architecture)
- 웹사이트의 모든 자원에 고유한 ID(HTTP URI)를 부여한다.
- CRUD
  - Create - POST
  - Read - GET
  - Update - PUT
  - Delete - DELETE
  - HEAD - HEAD
- 구성요소
  - 자원(URI):URI
  - 행위(Verb): HTTP Method
  - 표현(Representation of Resource)
- Server-Client 구조 : 자원이 있는쪽 Server, 요청하는 쪽 Client 둘은 분리 되어있음
- Stateless : HTTP 프로토콜기반이기에 REST역시 무상태성을 가짐 -> 서버는 요청만을 단순 처리함
- Chaceable : 캐시 사용이 가능
- Layered System : Client는 REST API Server만 호출하고 REST 서버는 다중 계층으로 구성 가능 Client -> API Server -> Security -> ...)
- Uniform Interface : URI로 지정한 자원에 대한 조작을 통일되고 한정적인 인터펭스로 수행함
- Code on Demand(optional) : 서버로부터 스크립트를 받아 클라이언트에서 실행할 수도 있음

- 장점
  - HTTP 프로토콜을 그대로 사용하므로 별도의 인프라를 구축할 필요가 없음
  - HTTP 프로토콜에 따르는 모든 플랫폼에서 사용이 가능하다.
  - Hypermedia API의 기본을 지키면서 범용성을 보장
(*hypermedia -얽혀있는 정보: 복잡한것, 바뀌는것, 확실하지 않은것을 위한 파일 구조(그래픽, 오디오, 영상, 텍스트 등))
  - 의도하는 바를 명확하게 나타내므로 쉽게 파악 할 수 있다. 
  - 서버와 클라이언트의 역할을 명확하게 분리한다.
- 단점
  - 표준이 존재하지 않는다
  - Method의 형태가 제한적이다. 
- 설계 기본 규칙
  - 도큐먼트 : 객체 인스턴스나 데이터베이스 레코드, 컬렉션 내의 구체적인 맴버
  - 컬렉션 : 서버에서 관리하는 디렉터리
  - 스토어 클라이언트에서 관리하는 리소스 저장소
   1) URI는 자원을 표현해야함
      - 동사보다는 명사, 대문자보다는 소문자 이용
      - 도큐먼트 이름 = 단수 명사 이용
      - 컬렉션 이름 = 복수 명사 이용
      - 스토어 이름 = 복수 명사 이용   
      ex) GET /Member/1 -> GET /members/1  --- members(컬렉션), 1(도큐먼트)
  2) 자원에 대한 행위는 HTTP Method로 표현
      - URI에 Method가 들어가면 안된다.
      - URI에 행위에 대한 동사 표현이 들어가면 안된다.
      - 경로 부분 중 변하는 부분은 유일 값으로 대체한다. id 등 
  3) 마지막 문자로 / 를 넣지 않는다.
  4) 불가피하게 긴 경로를 사용할 경우 (-)을 사용해가독성을 높이며 (_)은 이용하지 않는다.
  5) 확장자는 URI에 포함하지 않는다.
* REST아키텍처 스타일을 따르는 API -> REST API
* REST아키텍처를 완전하게 따라 만들어진 API -> RESTful API
* REST아키텍처를 구현하는 웹 서비스 -> RESTful 웹서비스

# 운영체제
## 프로세스와 스레드의 차이를 설명해보세요. (231101)
### 프로세스(Process)
- OS로부터 자원을 할당 받은 작업의 단위
![process](https://raw.githubusercontent.com/yys9905/CS_Study/main/yang/image/process.png)
- 프로그램을 실행시켜 해당 프로그램의 코드가 메모리 상에서 동작하고 있는 상태(프로그램(정적) -> 프로세스(동적)) 
- 각각의 프로세스는 독립적임
- 운영체제로 부터 Code, Data, Stack, Heap 을 할당 받아 사용됨 
- 프로세스당 최소 1개의 스레드를 가지고 있음
- 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신(IPC)을 사용해야함
![IPC](https://raw.githubusercontent.com/yys9905/CS_Study/main/yang/image/IPC.png)
[출처 위키백과, 프로세스 간 통신](https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%E2%9A%94%EF%B8%8F-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%B0%A8%EC%9D%B4)

### 스레드(Thread)
- 프로세스의 자원을 이용하는 실행 흐름의 단위
- 프로세스 내에서 각각 Stack만 할당 받고 Code, Data, Heap 영역은 공유한다.
- 한 스레드가 프로세스의 자원을 변경하면, 이웃 스레드도 변경 결과를 알 수 있음

### 멀티 프로세스/ 멀티 스레드
#### 멀티 프로세스
하나의 응용프로그램을 여러개의 프로세스로 구성해 각 프로세스가 하나의 작업을 처리하도록 하는 것
- 장점 : 프로세스 중 하나에 문제가 발생해도 영향이 확산되지 않음
- 단점 : Context Switching과정에서 무거운 작업들이 진행되고 오버해드가 발생함  
(*context Switching : CPU에서 여러 프로세스를 돌아가며 작업을 처리하는 과정, 현재 프로세스 대기 - 프로세스의 상태(Context )보관 -> 다음 순서의 프로세스 상태 복구 -> 다음 순서의 프로세스 동작) 

#### 멀티 스레드
여러개의 스레드로 구성해 각 스레드가 하나의 작업을 처리하도록 하는 것
- 장점
   - 자원 효율성 증가 : 자원을 공유하기에 새로 자원을 할당받지 않아도 되어 효율적으로 관리 가능
   - 처리 비용 감소 : 데이터를 주고받는 것이 간단해지며, 스레드사이의 작업량이 작아 Context Switching이 빠름
   - 응답시간 단축 : 프로세스 내의 모든 메모리를 공유하기에 부가적인 통신이 없어 통신 부담이 적음
- 단점
   - 설계시 주의해야한다.
   - 디버깅이 까다롭다.
   - 자원공유시 동기화 문제가 발생 할 수 있다.
   - 스레드 하나의 문제에 전체 프로세스가 영향을 받는다. 

# 프로그래밍 패러다임
## 객체지향과 절차지향에 대해 설명해주세요. (231025)
### 절차지향(Procedural)
프로그램의 순서와 흐름을 먼저 세우고, 필요한 자료구조와 함수들을 설계하는 방식 (C, Visual Basic, Fortran, Pascal, ...)
- TOP-DOWN 방식의 프로그래밍 : 큰 기능의 처리를 위해 작은 단위의 기능들로 나누어 처리하는 방식
ex) 사진을 찍는다 -> [카매라를 켠다 -> 원하는 모드를 선택한다 -> 초점을 맞춘다 -> 셔터를 누른다]
Main -> [func1 -> func2 -> func3 -> loop -> con1 -> ...]
- 데이터를 중심으로 구현이 되며 함수 호출(procedure call) 과정을 중심으로 설계가 된다.
- 순서대로 프로그램이 진행됨으로 순서가 바뀌면 결과가 달라진다.
- 프로그램이 커질수록 구조가 복잡해짐으로 유지보수가 어렵다.
- 데이터와 함수가 분리되어있어 데이터의 추적이 힘들다.
- 수행하는 알고리즘이 명확하고, 기능확장이 자주 일어나지 않는 상황에서 사용하기에 좋다.

### 객체지향(Object-Oriented)
자료구조와 모듈들을 설계하고, 실행 순서와 흐름을 짜는 방식 (C++, C#, Java, Python)
- 객체를 중심으로 구현이 되며, 객체간의 상호작용을 중심으로 설계된다.
- 상속, 캡슐화, 다형성의 특징으로 재사용성과 확장성이 좋아 유지보수가 쉽다.
- 실세계에 대한 모델링을 좀 더 쉽게 해준다.
- 캡슐화를 통해 정보를 은닉하여 보안성이 높다.
- 캡슐화와 격리구조로 절차지향보다 실행 속도가 느리다.
- 객체 단위의 구성으로 필요한 메모리 비용이 크다.
- 여러명이 협력을 해서 만들거나, 확장 가능하도록 코드를 설계해야 하는 경우에 적합하다.
- 객체하나하나가 속성(데이터)과, 메소드(함수)를 가지고 있다. 

#### 객체지향 프로그래밍 주요 특성
- 캡슐화 - 각각의 객체가 독립적인 역할을 할 수 있으며, 데이터와 기능을 객체를 통해 하나로 묶어서 관리하기에 필요에 따라 객체가 가진 속성과 메소드를 외부에 드러나지 않도록 은닉할 수 있다.
- 상속성 - 상위 클래스가 가진 데이터나 기능을 다른 클래스가 그대로 물려받는 것을 말한다. 
- 추상화 - 추상적인 개념(대략적인 형태)로만 구현되어있는 슈퍼클래스에 대해 서브클래스에서 객체에 맞도록 구현이 가능함.    
  (추상클래스 - 하위 객체들의 공통점을 모아 상위클래스로 구현해 놓은 것,    
  인터페이스 - 하위객체들에서 사용될 메소드나 속성들을 껍데기만 만들어 놓는 것)    
ex) 탈것 -> 자동차, 탈것 -> 비행기 :  자동차와 비행기는 탈것의 특징을 가지고 있으며 각각에 맞는 형태로 만들어진다. 예를들면 동력원 (자동차-자동차 엔진, 비행기-비행기 엔진), 이동이 가능(자동차-바퀴를 통해 이동, 비행기 - 날아서 이동), 사람을 태울 수 있음(사람을 n명 태울 수 있음)
- 다형성 - 하나의 객체에 여러 타입을 대입할 수 있는 성질
(오버라이딩 - 상속받은 메소드를 서브클래스에서 재정의 하는것, 오버로딩 - 같은 이름의 메소드가, 받는 파라미터(매개변수)에 따라 다르게 동작하는 것)

## 동기와 비동기 코드 실행방식에 대해 설명해주세요. (231027)
### 동기/비동기
순차적인 흐름의 유무를 결정 
#### 동기
- 직렬적으로 작동 - 이전 명령이 완료된 이후에 다음 명령이 작동하는 방식   
funcA -> funcA Fin -> funcB -> funcB Fin-> funcC -> funcC Fin -> ...
- ex) 순차적으로 처리되는 모든 프로세스 (UI 띄우기, 계산 ...)
#### 비동기
- 병렬적으로 작동 - 이전 명령의 상태와 상관없이 다음 명령을 실행하는 방식
funcA -> funcB -> funcA Fin -> func C -> funcC Fin -> funcB Fin -> ...   
- 동기보다 성능 우위 <- 대기시간 없이 동시 처리가 가능
- ex) 동시 처리가 필요하거나 하나의 작업이 완료되는데 시간이 많이걸리고 그동안 다른작업이 필요할때 (데이터베이스 처리, API 처리 ...)

[블로킹 논블로킹과의 조합](#sync-async-block-NonBlock-조합)

### 블로킹과 논블로킹
흐름의 차단 여부를 결정
#### 블로킹
- 제어권을 넘겨줌 - 명령이 수행되기 시작하면 프로그램 흐름의 제어권이 명령 수행중인 함수로 넘어감

#### 논블로킹
- 제어권을 넘겨주지 않음 - 명령을 시키고 제어권은 여전히 메인이 가지고 있음 

#### sync-async-block-NonBlock 조합
![S_As_B_Nb](https://raw.githubusercontent.com/yys9905/CS_Study/main/yang/image/S_As_B_Nb.png)
img 출처 : [Inpa Dev(tistory) - 완벽히 이해하는 동기/비동기 & 블로킹/논블로킹](https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC)

- 흔히 사용되는 동기 비동기 방식은 Sync_Block 방식과 Async_NBlock 방식이다.
- 상황에 따라서 Sync_NBlock과 Async_Block 방식도 사용하긴 함
- Sync_Block
  - 위에서 설명한 [동기방식](#동기)과 동일 
- Async_Non-Block
  - 위에서 설명한 [비동기방식](#비동기)와 동일
- Sync_Non-block
  - 제어권을 메인에서 가지고 있어 다른일을 수행할 수 있지만 FuncA가 완료되어야만 다음 작업이 가능할때 사용   
ex) 게임 로딩, 프로그래스바 - 둘다 제어권은 메인에서 가지고 있으며 로딩바의 작동은 지속적으로 보여지지만 데이터는 계속 로딩되고 있으며 로딩하고 있는 시스템에 계속해서 어느정도 로드 됬는지 조회한 후 로딩이 끝나야 다음 작업으로 넘어간다.
- Async_Block
  - 실수나 잘못 구현한 경우가 아닌 경우 sync_block과 차이가 없기에 거의 사용되지 않음
  - node.js와 MYSQL의 경우 node.js에서 비동기 방식의 쿼리를 보냈을떄 MySQL에서 블로킹을 하기때문에 결국엔 동기처리와 다르지 않게 된다고 한다. 
