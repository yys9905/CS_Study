<!------------------------------------------------------------------------------------------------ 1일차 ------------------------------------------------------------------------------------------------>
## 네트워크
<details>
  <summary> TCP와 UDP 차이점 </summary>
    <div markdown="1">

TCP는 **Transmission Control Protocol**으로, 전송 제어 프로토콜입니다.<br>
TCP는 신뢰성 있는 데이터 전송을 위해 사용되는 **연결지향 프로토콜**입니다.

UDP는 **User Datagram Protocol**으로 사용자 데이터그램 프로토콜입니다.<br>
UDP는 **빠른 데이터 전송을 중요시**하는 **비연결 프로토콜**입니다.<br>
두 단어 모두에게 존재하는 프로토콜(Protocol)이 디지털 장치간의 서로 통신하고 상호작용하기 위한 규칙의 집합입니다.

**TCP와 UDP의 차이점**은 다음과 같습니다:

**신뢰성**:
- TCP는 데이터 손실이나 순서의 뒤섞임이 발생하지 않습니다.
- UDP는 정확성을 확인하거나 재전송을 요청할 수 없기에 데이터가 손실 되거나 순서가 뒤섞일 수 있습니다.

**연결**:
- TCP는 데이터를 전송하기 전에 연결을 설정하고, 전송 후 연결을 해제합니다. 연결 및 해제과정에서 추가적인 오버헤드는 초래할 수 있으나, 신뢰성 있는 통신을 보장합니다. (오버헤드: 데이터전송 및 처리 과정에서 추가 부담이나 리소스 낭비를 뜻함)
- UDP는 연결 및 해제 단계가 없기에 빠른 전송이 가능하지만 데이터의 무결성을 보장하지 않습니다.

**사용사례**:
- TCP는 주로 이메일, 파일 전송과 같이 신뢰성이 중요한 경우 사용됩니다.
- UDP는 실시간 스트리밍, 온라인 게임, 음성통화 같이 데이터 전송 속도가 중요한 경우 사용됩니다.

![TCP의 3way&4way](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbHoWOZ%2FbtsyQSUDDPR%2FzSvULeIM1LJunmoUVinc4k%2Fimg.png)

"SYN"은 "Synchronize"의 약자로 동기입니다.
"ACK"는 "Acknowledgment"의 약자로 승인입니다.
"FIN"은 "Finish"의 약자로 종료입니다. 그 과정을 리눅스를 통해 3way, 4way인 것이 보입니다.
중간의 P의 경우, 패킷의 약자로 데이터 패킷을 전송하는 과정입니다.

**TCP 패킷의 재전송 과정**:
1. 패킷 송신: 송신자는 여러 개의 패킷으로 나눠 수신자에게 보냄. 각 패킷은 고유한 일련번호를 가지고 있습니다.
2. 패킷 수신: 수신자는 패킷을 받고, 패킷의 일련번호를 확인하여 순서대로 재조립합니다.
3. 패킷 손실 확인: 만약 패킷이 손실되었다고 감지하면, 송신자에게 패킷 손실을 알리기 위한 메시지를 보냅니다.
4. 재전송 요청: 송신자는 손실된 패킷을 재전송하고, 이 패킷의 일련번호를 통해 수신자는 어떤 패킷이 재전송된 것인지 판단할 수 있습니다.
5. 패킷 재전송: 재전송된 패킷은 수신자에게 도착하고 재조립합니다.

**TCP 세션 관리 (연결의 설정과 종료 과정) - Easy Version**:
- 연결 설정 (Handshake): 두 컴퓨터 간의 통신을 먼저 연결 설정해야 합니다. 이 단계를 연결 설정 또는 핸드쉐이크라고 부릅니다.
- 데이터 전송: 연결 설정 후, 데이터를 주고 받을 수 있습니다. A는 작은 조각으로 나눠 B에게 보내면 재조립하여 사용합니다.
- 연결 해제 (Termination): 데이터 통신이 끝난 후, 연결을 해제합니다. A는 B에게 끝내고자 하는 의사를 전달합니다. B는 요청을 수락하고 연결이 종료됩니다.

![TCP의 통신방식](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbaYyaw%2FbtsyPwLxTLK%2FOUwLGVUiHYa0ij2pZNQI8K%2Fimg.png)
- 연결 지향 방식, 패킷 교환방식
- 3way handshaking 으로 연결 4way handshaking으로 해제
- 흐름제어 - 송.수신측의 데이터 처리속도 차이 줄이기 위함, receiver가 현재 상태를 sender에게 피드백해 패킷 수를 조절
- 혼잡 제어 - 송신측의 데이터 전달과 네트워크 데이터 처리 속도 차이를 해결 하기 위함
- 높은 신뢰성- 낮은 성능
- 전이중(각각의 독립된 회선 사용), 점대점(1대1통신) 방식
- 각각의 패킷들은 연결되어있으며 번호가 매겨짐
- 신뢰성있는 전송이 필요할때 사용
- 가변길이 헤더
  
![UDP의 통신방식](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F6tEyH%2FbtsyOFvfD9d%2FvQXKydWBR3KTHCKTRvwZc0%2Fimg.png)
- 비연결형 방식, 데이터그램 방식
- 정보를 주고받을떄 신호절차를 가지고 있지 않음
- UDP헤더의 CheckSum 필드로 최소한의 오류 검출
- 낮은 신뢰성 -높은 성
- 각각의 패킷들은 독립되어있다
- 빠른 전송이 필요할때 사용
- 고정 길이 헤더
- 일반적으로는 저런 내용이지만 UDP는 커스터마이징이 가능하며 개발자의 역량에 따라서 UDP를 이용해 TCP와 비슷한 신뢰성 가지게 할 수 있음 ex) QUIC
  </div>
</details>

<!------------------------------------------------------------------------------------------------ 2일차 ------------------------------------------------------------------------------------------------>

## 암호학/보안
<details>
<summary> 비대칭키 암호화, 대칭키 암호화에 대해 간단히 설명해주세요. </summary>
<div markdown="1">
대칭키 암호화는 암호화와 복호화에 같은 키를 사용하는 암호화 방식입니다.

비대칭키 암호화는 암호화와 복호화에 다른 키를 사용하는 암호화 방식입니다.

### 1. 대칭키(비밀키) 암호화

**장점**: 데이터를 암호화하기 위한 연산이 빨라 대용량 데이터 암호화에 적합, 구현이 용이, 기밀성을 제공
**단점**: 키를 교환해야하는 문제, 탈취 관리 걱정, 사람이 증가할 수록 키 관리가 어려움, 확장성 떨어짐

- 하나의 비밀키를 서버와 클라이언트 모두 함께 사용
- 암호화와 복호화에 같은 키를 사용하는 방식
- 비밀키 하나만 알아내면 암호화된 내용 해킹 가능
- 속도가 빠르다는 장점이 있지만, 키를 교환해야 한다는 문제가 있어서 중간에 탈취 당해 해킹당할 수 있다.
- (위험한 이유: 처음 상대방에게 대칭키를 전송하는 과정에서 탈취당하면 통신 내용 모두 해킹 가능)
- 서로 키를 보관해야 하기 때문에 관리해야 할 키가 방대해질 수 있다.

![대칭키(비밀키)](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FGTeWO%2Fbtsy2oZWZpu%2FTuxdc1d3GLkKjLF0shMa3K%2Fimg.png)

**대칭키(비밀키) 암호화의 종류**

- DES(Data Encryption Standard): 64-비트 블록 암호, 56-비트 비밀키 사용
- AES(Advanced Encryption Standard): 128-비트 블록 암호, 안전성 문제로 인해 DES 대체
- 아리아(ARIA): 한국에서 개발된 128-비트 블록 암호
- 시드(SEED): 한국에서 개발된 128-비트 블록 암호

### 2. 비대칭키(공개키) 암호화

**장점**: 키 분배 및 키 관리 용이, 기밀성/인증/부인 방지 기능 제공
**단점**: 속도가 느림, 상대적으로 키의 길이가 길다
  </div>
</details>


<!------------------------------------------------------------------------------------------------ 3일차 ------------------------------------------------------------------------------------------------>

## 프로그래밍 패러다임
<details>
<summary> 객체지향과 절차지향에 대해 설명해주세요. </summary>
<div markdown="1">
  
## 절차지향 => 객체지향으로 바뀌는 이유

**절차지향 프로그래밍** 이란 물이 위에서 아래로 흐르는 것처럼 순차적인 처리가 중요시 되며, 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법으로 대표적인 절차지향 언어는 C언어가 있습니다.
장점은 컴퓨터의 처리구조와 유사해 실행속도가 빠르지만,단점으로 유지보수가 어렵고, 실행 순서가 정해져 있으므로 코드 순서가 바뀌면 동일한 결과를 보장하기 어려우며, 디버깅하기도 어렵습니다.
<br>
<br>
하지만 하드웨어의 발전으로, 성능에 조금 부담을 주더라도 큰 단점이 아니게 되었기에 모듈화, 캡슐화해서 개념적으로 접근하는 형태를 갖는 객체지향 프로그래밍이 탄생했습니다.
<br>
<br>
**객체 지향 프로그래밍(Object-Oriented Programming, OOP)** 은 프로그램을 객체라는 독립된 단위들의 모임으로 보고 개발하는 것입니다. 객체는 상태와 행위를 가지며, 
서로 메시지를 주고받고 데이터를 처리할 수 있습니다. 이러한 객체들이 서로 상호작용하면서 프로그램을 구성하는 것이 객체 지향 프로그래밍의 핵심입니다
<br>

## 절차지향 프로그래밍 (Procedural Programming)

절차지향 프로그래밍은 프로그램을 물 흐르듯 순차적으로 처리하는 방식으로, 대표적인 절차지향 언어는 C언어입니다.

**장점**:
- 컴퓨터의 처리구조와 유사하여 실행속도가 빠르다.
- 하드웨어의 발전으로 인해 성능 부담이 줄었다.

**단점**:
- 유지보수가 어렵다.
- 실행 순서가 고정되어 코드 순서 변경 시 동일한 결과를 보장하기 어렵다.
- 디버깅이 어렵다.

## 객체지향 프로그래밍 (Object-Oriented Programming, OOP)

객체지향 프로그래밍은 프로그램을 객체라는 독립된 단위들의 모임으로 보고 개발하는 방식입니다. 객체는 상태와 행동을 가지며, 서로 메시지를 주고받고 데이터를 처리할 수 있습니다.

### 객체지향 프로그래밍의 주요 특징:

1. **추상화 (Abstraction)**: 필요한 정보 중심으로 간소화된 모델을 제공합니다.

2. **캡슐화 (Encapsulation)**: 데이터와 기능을 하나로 묶어서 외부에 드러나지 않도록 합니다.

3. **상속성 (Inheritance)**: 클래스가 가진 데이터와 기능을 다른 클래스에 물려줍니다.

4. **다형성 (Polymorphism)**: 하나의 클래스나 메서드가 다양한 방식으로 동작할 수 있도록 합니다.

**장점**:
- 코드 재사용 및 확장 용이.
- 복잡한 프로그램을 객체 단위로 모델링하므로 유지보수가 쉽다.
- 캡슐화로 보안성이 높다.

**단점**:
- 실행 속도가 상대적으로 느리다.
- 메모리 사용량이 많을 수 있다.

### 절차지향 vs. 객체지향:

| 특성        | 절차지향              | 객체지향                |
|-------------|------------------------|--------------------------|
| 접근 방식   | Top-Down               | Bottom-Up                |
| 구성 요소   | 함수                   | 객체                     |
| 접근 제어   | 없음                   | public, protected, private |
| 다형성     | 불가능                | 함수, 생성자, 연산자 등 오버로딩 가능 |
| 상속        | 불가능                | 가능                     |
| 보안성     | 낮음                   | 높음                     |
| 데이터 공유 | 모든 함수 공유          | 객체 간 멤버 함수로만 공유 |

## 요약 및 참고 이미지

- 절차지향은 데이터 중심, 객체지향은 기능 중심입니다.
- 객체지향은 상속, 캡슐화, 다형성을 활용해 코드를 재사용하거나 확장하기 좋습니다.

![절차지향 vs 객체지향)](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcUDYl5%2Fbtsy9hU9Ce4%2FRRTEKUeF9IrR5xUJ7S1Wi1%2Fimg.png)
![절차지향 vs 객체지향)](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F2WX4V%2Fbtsy9gIOy1j%2Fxqm4a2LvgwOFxPT4j5XYlK%2Fimg.png)

</div>
</details>

<!------------------------------------------------------------------------------------------------ 4일차 ------------------------------------------------------------------------------------------------>

<details>
<summary> 동기와 비동기 코드 실행방식에 대해 설명해주세요. </summary>
  <div markdown="1">

![동기 vs 비동기](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbUe0qA%2FbtszjDWMFQo%2FS1sHuCz8yhoUkYKlIaek41%2Fimg.png)

**동기(Synchronous)** 와 **비동기(Asynchronous)**
**동기**는 요청을 보낸 후 응답을 받아야지만 다음 동작이 이루어지는 방식이다. <br>
어떠한 태스크를 처리할 동안 나머지 태스크는 대기한다. <btr>
실제로 cpu가 느려지는 것은 아니지만 시스템의 전체 효율이 저하된다고 할 수 있다. <br>

![동기식 처리모델](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FclMBVS%2Fbtszi7KCodC%2FNqfGUderS41KWxaG9CSUA0%2Fimg.png)

```
function func1(){
	console.log('1');
  func2();
}
function func2(){
	console.log('2');
  func3();
}
function func3(){
	console.log('3');
}

func1();
//결과 1,2,3
```

비동기는 요청을 보낸 후 응답의 수락 여부와는 상관없이 다음 태스크가 동작하는 방식이다. 자원을 효율적으로 사용할 수 있다. 이때, 비동기 요청시 응답 후 처리할 Callback 함수를 함께 알려준다. 하지만 비동기 처리를 위해 여러 콜백함수를 중첩시키면 콜백지옥이 발생한다. 이를 해결하기 위해 Promise를 도입하였고, Async / Await 추가로 도입되었다. (Async / Await는  JavaScript에서 비동기 처리를 동기적인 방식으로 작성하게 해주는 문법)

![비동기식 처리모델](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdZAmIj%2FbtszhvrtLF3%2FaBMUHmCpZjd0WmWdvxlkYk%2Fimg.png)

function func1() { 
  setTimeout(function(){
  console.log('1');
  }, 1000);
  func2(); 
} 
function func2() { 
  setTimeout(function() {
    console.log('2');
  }, 500); 
  func3(); 
} 
function func3() { 
  setTimeout(function(){
    console.log('3');
  }, 1500);
}

func1();

//결과 2, 1, 3

동기가 사용되는 예시
파일 시스템에서 파일을 읽는 작업: 파일을 읽은 후 해당 내용으로 작업하는 경우
데이터베이스에서 데이터를 읽어오는 작업 : DB에서 데이터를 읽은 후, 그 데이터를 다음 작업을 수행해야 하는 경우 동기처리가 필요함 (반대로 데이터 추출 작업이 빈번한 경우, 비동기식으로 하기도 함)

async createCollection(userId: number, name: string) {
try {
  const newBookmark = await this.collectionRepository.insert({
    user_id: userId,
  });
}

비동기가 사용되는 예시
웹 API 호출 : API를 호출하고 기다리는 동안 다른 작업도 수행
setTimeOut 함수 : 주어진 시간이 지난후 특정함수가 실행되는 함수로 함수가 실행되는동안 다른 작업도 수행

블로킹과 논블로킹
흐름의 차단 여부를 결정

블로킹
제어권을 넘겨줌 - 명령이 수행되기 시작하면 프로그램 흐름의 제어권이 명령 수행중인 함수로 넘어감
논블로킹
제어권을 넘겨주지 않음 - 명령을 시키고 제어권은 여전히 메인이 가지고 있음

![동기비동기 블로킹논블로](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fdt2nzc%2Fbtszhn1l2NQ%2F2mrpkKgUHf4gQm6HycWnBK%2Fimg.png)

Sync_Block -- 위에서 설명한 동기방식과 동일
Async_Non-Block -- 위에서 설명한 비동기방식와 동일
Sync_Non-block -- 제어권을 메인에서 가지고 있어 다른일을 수행할 수 있지만 FuncA가 완료되어야만 다음 작업이 가능할때 사용 ex) 게임 로딩, 프로그래스바 - 둘다 제어권은 메인에서 가지고 있으며 로딩바의 작동은 지속적으로 보여지지만 데이터는 계속 로딩되고 있으며 로딩하고 있는 시스템에 계속해서 어느정도 로드 됬는지 조회한 후 로딩이 끝나야 다음 작업으로 넘어간다.
Async_Block -- 실수나 잘못 구현한 경우가 아닌 경우 sync_block과 차이가 없기에 거의 사용되지 않음 -- node.js와 MYSQL의 경우 node.js에서 비동기 방식의 쿼리를 보냈을떄 MySQL에서 블로킹을 하기때문에 결국엔 동기처리와 다르지 않게 된다고 한다.
  </div>
</details>





